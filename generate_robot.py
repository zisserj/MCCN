
# Remember model is 1-idx

x_size = 8
y_size = 5

gridsize = (x_size, 5)
down_bumpers = [(i, 2) for i in range(2, x_size)] + [(x_size-1, 1)]
up_bumpers = [(i, y_size-1) for i in range(2, x_size)] + [(x_size-1, y_size)]


robot_init = (1,1)
robot_goal = (x_size, y_size-1)
pickups = [(x_size, 1), (3, y_size), (1,3)] # pickups on bumpers don't work
target_pickups = 2


filename = 'dtmcs/robot_biased.pm'
# storm --prism robot_auto.pm --buildfull --prismcompat --engine sparse --exportbuild robot.drn

program_header = '''// Based on GRID WORLD MODEL OF ROBOT AND JANITOR
// Hakan Younes/gxn/dxp 04/05/04
// automatically generated by "generate_robot.py"
dtmc

// CONSTANTS
const int xn = {}; // size of the grid
const int yn = {};

// the following formulae return 1 or 0 depending on whether
// the robot can move in that direction or not
formula right = min(1,max(xn-x1,0));
formula left = min(1,max(x1-1,0));
formula up = min(1,max(yn-y1,0));
formula down = min(1,max(y1-1,0));

// total number of moves the robot randomly picks from
formula moves = right+left+up+down;
formula ns = up+down;
formula ew = right+left;
'''.format(*gridsize)

program_robot = '''module robot
	x1 : [1..xn] init 1; // x position of robot (bottom left)
	y1 : [1..yn] init 1; // y position of robot
	
	[move] (ns=2) -> (up+0.1)/moves:(y1'=y1+1) + (down-0.1)/moves:(y1'=y1-1) + left/moves:(x1'=x1-1) + right/moves:(x1'=x1+1); 
	[move] (ns!=2) & (ew=2) -> up/moves:(y1'=y1+1) + down/moves:(y1'=y1-1) + (left-0.2)/moves:(x1'=x1-1) + (right+0.2)/moves:(x1'=x1+1); 
 	[move] (ns!=2) & (ew!=2) -> up/moves:(y1'=y1+1) + down/moves:(y1'=y1-1) + left/moves:(x1'=x1-1) + right/moves:(x1'=x1+1); 
	[bump_down] ({}) & (down=1) -> 1: (y1'=y1-1);
    [bump_up] ({}) & (up=1) -> 1: (y1'=y1+1);
endmodule
'''.format('|'.join([f'on_db{i+1}' for i in range(len(down_bumpers))]),
           '|'.join([f'on_ub{i+1+len(down_bumpers)}' for i in range(len(up_bumpers))]))

pick_module = lambda i, pos: f'''module pickup{i}
	rx{i} : [1..xn] init {pos[0]};
	ry{i} : [1..yn] init {pos[1]};
	picked{i}: [0..1] init 0;
	[move] !on_pick{i} | picked{i}=1 -> 1: true;
	[move] on_pick{i} & picked{i}=0 -> 1: (picked{i}' = 1);
endmodule
formula on_pick{i} = rx{i} = x1 & ry{i} = y1;
'''

db_module = lambda i, pos: f'''module down_bumper{i}
	cx{i} : [1..xn] init {pos[0]};
	cy{i} : [1..yn] init {pos[1]};
	[bump_down] true -> 1: true;
	[move] !on_db{i} -> 1: true; 
endmodule
formula on_db{i} = cx{i} = x1 & cy{i} = y1;
'''

ub_module = lambda i, pos: f'''module up_bumper{i}
	cx{i} : [1..xn] init {pos[0]};
	cy{i} : [1..yn] init {pos[1]};
	[bump_up] true -> 1: true;
	[move] !on_ub{i} -> 1: true; 
endmodule
formula on_ub{i} = cx{i} = x1 & cy{i} = y1;
'''

pickup_sum = "+".join([f'picked{i}' for i in range(1, len(pickups)+1)])
target = 'label "target" = x1={} & y1={} & ({} >= {});'.format(*robot_goal, pickup_sum, target_pickups)

program_pick = '\n'.join([pick_module(i, pos) for i, pos in enumerate(pickups, 1)])
program_db = '\n'.join([db_module(i, pos) for i, pos in enumerate(down_bumpers, 1)])
program_ub = '\n'.join([ub_module(i, pos) for i, pos in enumerate(up_bumpers, 1+len(down_bumpers))])

with open(filename, 'w+') as f:
    f.writelines([program_header, program_robot,
                  program_pick, program_db, program_ub, target])
